use eframe::egui;
use image::{Rgba, RgbaImage};

pub(crate) fn draw_text_bitmap(
    img: &mut RgbaImage,
    pos: egui::Pos2,
    text: &str,
    color: egui::Color32,
    scale: u32,
) {
    let mut x = pos.x.round() as i32;
    let y = pos.y.round() as i32;
    for ch in text.chars() {
        if ch == '\n' {
            x = pos.x.round() as i32;
            continue;
        }
        draw_char_5x7(img, x, y, ch, color32_to_rgba(color), scale);
        x += 6 * scale as i32;
    }
}

pub(crate) fn text_bitmap_size(text: &str, scale: u32) -> (i32, i32) {
    let width = text.chars().count() as i32 * 6 * scale as i32;
    let height = 7 * scale as i32;
    (width, height)
}

pub(crate) fn circlecount_text_scale(bubble_size: f32, text: &str) -> u32 {
    let mut scale = (bubble_size / 7.0).floor().max(1.0) as u32;
    let max_width = bubble_size.max(1.0) as i32;
    while scale > 1 {
        let (width, _) = text_bitmap_size(text, scale);
        if width <= max_width {
            break;
        }
        scale -= 1;
    }
    scale.max(1)
}

fn draw_char_5x7(
    img: &mut RgbaImage,
    x: i32,
    y: i32,
    ch: char,
    color: Rgba<u8>,
    scale: u32,
) {
    let Some(glyph) = glyph_5x7(ch) else {
        return;
    };
    for (col, bits) in glyph.iter().enumerate() {
        for row in 0..7 {
            if (bits >> row) & 1 == 1 {
                for sx in 0..scale {
                    for sy in 0..scale {
                        let px = x + (col as i32 * scale as i32) + sx as i32;
                        let py = y + (row as i32 * scale as i32) + sy as i32;
                        if px >= 0
                            && py >= 0
                            && (px as u32) < img.width()
                            && (py as u32) < img.height()
                        {
                            img.put_pixel(px as u32, py as u32, color);
                        }
                    }
                }
            }
        }
    }
}

fn glyph_5x7(ch: char) -> Option<[u8; 5]> {
    let c = ch.to_ascii_uppercase();
    let glyph = match c {
        '0' => [0x3E, 0x51, 0x49, 0x45, 0x3E],
        '1' => [0x00, 0x42, 0x7F, 0x40, 0x00],
        '2' => [0x42, 0x61, 0x51, 0x49, 0x46],
        '3' => [0x21, 0x41, 0x45, 0x4B, 0x31],
        '4' => [0x18, 0x14, 0x12, 0x7F, 0x10],
        '5' => [0x27, 0x45, 0x45, 0x45, 0x39],
        '6' => [0x3C, 0x4A, 0x49, 0x49, 0x30],
        '7' => [0x01, 0x71, 0x09, 0x05, 0x03],
        '8' => [0x36, 0x49, 0x49, 0x49, 0x36],
        '9' => [0x06, 0x49, 0x49, 0x29, 0x1E],
        'A' => [0x7E, 0x11, 0x11, 0x11, 0x7E],
        'B' => [0x7F, 0x49, 0x49, 0x49, 0x36],
        'C' => [0x3E, 0x41, 0x41, 0x41, 0x22],
        'D' => [0x7F, 0x41, 0x41, 0x22, 0x1C],
        'E' => [0x7F, 0x49, 0x49, 0x49, 0x41],
        'F' => [0x7F, 0x09, 0x09, 0x09, 0x01],
        'G' => [0x3E, 0x41, 0x49, 0x49, 0x3A],
        'H' => [0x7F, 0x08, 0x08, 0x08, 0x7F],
        'I' => [0x00, 0x41, 0x7F, 0x41, 0x00],
        'J' => [0x20, 0x40, 0x41, 0x3F, 0x01],
        'K' => [0x7F, 0x08, 0x14, 0x22, 0x41],
        'L' => [0x7F, 0x40, 0x40, 0x40, 0x40],
        'M' => [0x7F, 0x02, 0x0C, 0x02, 0x7F],
        'N' => [0x7F, 0x04, 0x08, 0x10, 0x7F],
        'O' => [0x3E, 0x41, 0x41, 0x41, 0x3E],
        'P' => [0x7F, 0x09, 0x09, 0x09, 0x06],
        'Q' => [0x3E, 0x41, 0x51, 0x21, 0x5E],
        'R' => [0x7F, 0x09, 0x19, 0x29, 0x46],
        'S' => [0x46, 0x49, 0x49, 0x49, 0x31],
        'T' => [0x01, 0x01, 0x7F, 0x01, 0x01],
        'U' => [0x3F, 0x40, 0x40, 0x40, 0x3F],
        'V' => [0x1F, 0x20, 0x40, 0x20, 0x1F],
        'W' => [0x7F, 0x20, 0x18, 0x20, 0x7F],
        'X' => [0x63, 0x14, 0x08, 0x14, 0x63],
        'Y' => [0x03, 0x04, 0x78, 0x04, 0x03],
        'Z' => [0x61, 0x51, 0x49, 0x45, 0x43],
        '-' => [0x08, 0x08, 0x08, 0x08, 0x08],
        '_' => [0x40, 0x40, 0x40, 0x40, 0x40],
        '.' => [0x00, 0x60, 0x60, 0x00, 0x00],
        ':' => [0x00, 0x36, 0x36, 0x00, 0x00],
        '/' => [0x20, 0x10, 0x08, 0x04, 0x02],
        '+' => [0x08, 0x08, 0x3E, 0x08, 0x08],
        '*' => [0x14, 0x08, 0x3E, 0x08, 0x14],
        '?' => [0x02, 0x01, 0x51, 0x09, 0x06],
        '!' => [0x00, 0x00, 0x5F, 0x00, 0x00],
        ' ' => [0x00, 0x00, 0x00, 0x00, 0x00],
        _ => return None,
    };
    Some(glyph)
}

fn color32_to_rgba(color: egui::Color32) -> Rgba<u8> {
    Rgba([color.r(), color.g(), color.b(), color.a()])
}
